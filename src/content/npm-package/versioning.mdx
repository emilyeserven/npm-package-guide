---
id: "versioning"
title: "Versioning üè∑Ô∏è"
guide: "npm-package"
usedFootnotes: [1, 2, 3, 4, 5, 6]
linkRefs:
  - id: "semver-spec"
  - id: "npm-semver-calculator"
  - id: "changesets"
  - id: "semantic-release"
  - id: "conventional-commits"
  - id: "wiki-changelog"
    note: "A file documenting notable changes for each version ‚Äî helps consumers decide when and whether to upgrade"
---

<SectionTitle>{frontmatter.title}</SectionTitle>

<Toc>
  <TocLink id="toc-webapp">Web App</TocLink>
  <TocLink id="toc-pkg">NPM Package</TocLink>
  <TocLink id="toc-explainer">What's semver and how does CI help?</TocLink>
  <TocLink id="toc-gotcha">Watch out</TocLink>
</Toc>

<SectionSubheading id="toc-webapp">{'\u{1F310}'} Web App</SectionSubheading>
<SectionList>
<ColItem>You deploy continuously ‚Äî users always get the latest version automatically.</ColItem>
<ColItem>If you ship a bug, you can hotfix and redeploy in minutes.</ColItem>
<ColItem>Version numbers exist but are mostly internal ‚Äî users never see them.</ColItem>
</SectionList>

<SectionSubheading id="toc-pkg">{'\u{1F4E6}'} NPM Package</SectionSubheading>
<SectionList>
<ColItem>You follow 'semver'<FnRef n={1} /> (semantic versioning): MAJOR.MINOR.PATCH ‚Äî e.g., 2.1.3.</ColItem>
<ColItem>Published versions are essentially permanent. Consumers pin versions, so a bug might live in their project for months.</ColItem>
<ColItem>In a CI pipeline, tools like changesets<FnRef n={3} /> or semantic-release<FnRef n={4} /> can automate version bumps. They analyze your commit messages (e.g., 'feat:' ‚Üí minor, 'fix:' ‚Üí patch, 'BREAKING CHANGE:' ‚Üí major), generate changelogs, and publish to npm ‚Äî all triggered by merging a PR.</ColItem>
</SectionList>

<Explainer title="What's semver and how does CI help?">
Semantic Versioning (semver) is a contract with your users. Given version MAJOR.MINOR.PATCH: bump MAJOR when you make incompatible API changes (like renaming a function), bump MINOR when you add functionality in a backward-compatible way, and bump PATCH for backward-compatible bug fixes. When someone installs '^2.1.0', they trust that any 2.x.x update won't break their code. In practice, most teams automate this with CI. A tool like 'changesets' lets developers declare version intent in their PRs, then a CI pipeline (GitHub Actions, etc.) handles the actual version bump, changelog<FnRef n={6} /> generation, and npm publish when PRs are merged. 'semantic-release' takes a different approach ‚Äî it reads Conventional Commit<FnRef n={5} /> messages to determine the version automatically. Either way, CI removes the human error of forgetting to bump or mis-categorizing a change.
</Explainer>

<Gotcha>
Semver trust is everything. MAJOR = breaking changes, MINOR = new features, PATCH = bug fixes. If you accidentally break something in a minor release, developers lose trust fast ‚Äî it's like changing a REST API response shape without bumping the API version. CI automation helps prevent human error here. Use the npm semver calculator<FnRef n={2} /> to understand version ranges.
</Gotcha>
