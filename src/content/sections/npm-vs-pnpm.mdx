---
id: "npm-vs-pnpm"
title: "npm vs pnpm üì¶"
group: "concepts"
usedFootnotes: [1, 2, 3, 4, 5, 6]
linkRefs:
  - id: "pnpm-motivation"
  - id: "pnpm-feature-comparison"
  - id: "npm-cli-commands"
  - id: "pnpm-cli-add"
  - id: "pnpm-installation"
  - id: "wiki-symlink"
    note: "A symlink is a file that points to another file or directory ‚Äî pnpm uses these to avoid duplicating packages on disk"
---

<SectionTitle>{frontmatter.title}</SectionTitle>

<Toc>
  <TocLink id="toc-col1">npm</TocLink>
  <TocLink id="toc-col2">pnpm</TocLink>
  <TocLink id="toc-explainer">npm vs pnpm ‚Äî a backend analogy</TocLink>
  <TocLink id="toc-gotcha">Watch out</TocLink>
</Toc>

<SectionIntro>
npm and pnpm are both package managers for JavaScript ‚Äî they install dependencies, run scripts, and manage your project's node_modules. npm comes bundled with Node.js and is the default, while pnpm<FnRef n={1} /> is a faster, stricter alternative that's become the preferred choice for monorepos and large projects. You can switch between them on any project, but it's best to pick one early and stick with it.
</SectionIntro>

<SectionSubheading id="toc-col1">{'\u{1F4D7}'} npm</SectionSubheading>
<SectionList>
<ColItem>npm (Node Package Manager) is the default ‚Äî it ships with every Node.js installation, so there's nothing extra to install. If you're new to JavaScript, this is where you start.</ColItem>
<ColItem>It uses a flat node_modules structure, which can lead to 'phantom dependencies' ‚Äî your code can accidentally import packages you didn't explicitly install. This is rarely a problem for small projects.</ColItem>
<ColItem>npm workspaces support monorepos, but the implementation is basic. For single-package repos and getting started, npm is the simplest choice with the most community examples. See the npm CLI docs<FnRef n={3} /> for the full command reference.</ColItem>
</SectionList>

<SectionSubheading id="toc-col2">{'\u{1F7E0}'} pnpm</SectionSubheading>
<SectionList>
<ColItem>pnpm is a drop-in replacement for npm that's significantly faster (2-3x in benchmarks) and uses much less disk space by symlinking<FnRef n={6} /> packages from a shared store instead of copying them.</ColItem>
<ColItem>It uses a strict node_modules structure that prevents phantom dependencies ‚Äî you can only import what you've explicitly declared. This catches real bugs that npm silently ignores.</ColItem>
<ColItem>pnpm's workspace support is more mature and performant than npm's, which is why it's the recommended package manager for monorepos. Most major open-source projects (Vue, Vite, Turborepo) use pnpm. See the pnpm CLI docs<FnRef n={4} /> and the install guide<FnRef n={5} /> to get started.</ColItem>
</SectionList>

<Explainer title="npm vs pnpm ‚Äî a backend analogy">
Think of npm like pip ‚Äî it comes with the language runtime, it works, and everyone knows it. pnpm is more like Poetry for Python or Cargo for Rust ‚Äî a more modern, opinionated tool that enforces best practices. The symlink-based store in pnpm is similar to how Docker layers share common base images instead of duplicating them ‚Äî you save disk space and gain speed because shared packages only exist once on your machine. The strict dependency resolution is like having your imports validated at compile time rather than discovering missing dependencies at runtime.
</Explainer>

<Gotcha>
‚ö†Ô∏è Some older tutorials and boilerplates assume npm. If you see 'npm install', you can almost always substitute 'pnpm install' ‚Äî the commands are nearly identical. The main gotcha: pnpm's strict dependency resolution means packages that rely on phantom dependencies may break. This is actually pnpm catching a real bug, not a pnpm issue. See the feature comparison<FnRef n={2} /> for a detailed breakdown.
</Gotcha>
