---
id: "arch-frameworks-intro"
title: "Full-Stack Frameworks üè†"
guide: "architecture"
usedFootnotes: [2]
links:
  - label: "React documentation"
    url: "https://react.dev/learn"
    source: "React"
  - label: "Rendering on the Web"
    url: "https://web.dev/articles/rendering-on-the-web"
    source: "web.dev"
    note: "Comprehensive guide to rendering strategies: SSR, CSR, SSG, and hybrid approaches"
  - label: "Server-side rendering vs client-side rendering"
    url: "https://web.dev/articles/rendering-on-the-web#server-rendering"
    source: "web.dev"
---

<SectionTitle>{frontmatter.title}</SectionTitle>

<Toc>
  <TocLink id="toc-what">What is a full-stack framework?</TocLink>
  <TocLink id="toc-stacks-vs-frameworks">Stacks vs. frameworks</TocLink>
  <TocLink id="toc-the-frameworks">The four frameworks</TocLink>
  <TocLink id="toc-explainer">Backend analogy</TocLink>
</Toc>

<SectionIntro>
Full-stack frameworks take a frontend library (like React) and add server rendering, routing, data fetching, and build optimization &mdash; creating a unified development experience. Instead of assembling independent pieces yourself, a framework makes these decisions for you.
</SectionIntro>

<SectionSubheading id="toc-what">{'\u{1F4CB}'} What is a full-stack framework?</SectionSubheading>

In the previous sections, you learned about **stacks** &mdash; collections of independent technologies at different layers (frontend, server, runtime, database). You choose each piece separately and wire them together.

**Full-stack frameworks** take a different approach. They start with a frontend library (usually React) and add server-side capabilities on top:

<SectionList>
<ColItem>**Server rendering** &mdash; generate HTML on the server for faster initial loads and better SEO<FnRef n={2} /></ColItem>
<ColItem>**File-system routing** &mdash; your file structure automatically becomes your URL structure</ColItem>
<ColItem>**Data fetching** &mdash; load data on the server before sending pages to the browser</ColItem>
<ColItem>**Build optimization** &mdash; automatic code splitting, bundling, and asset optimization</ColItem>
</SectionList>

<SectionSubheading id="toc-stacks-vs-frameworks">{'\u{1F504}'} Stacks vs. frameworks</SectionSubheading>

The key difference is **who makes the integration decisions**:

<SectionList>
<ColItem>**Stacks** (MERN, LAMP, etc.) &mdash; you choose independent technologies at each layer and wire them together yourself. Maximum flexibility, but more decisions to make.</ColItem>
<ColItem>**Frameworks** (Next.js, React Router, etc.) &mdash; the framework handles server rendering, routing, and data fetching as a unified package. Fewer decisions, but you follow the framework&apos;s patterns.</ColItem>
</SectionList>

Frameworks don&apos;t replace stacks &mdash; they sit **on top** of them. Next.js still uses React (frontend) and Node.js (runtime). You still need a database. The framework handles the glue between layers so you don&apos;t have to.

<SectionSubheading id="toc-the-frameworks">{'\u{1F3D7}\uFE0F'} The four frameworks</SectionSubheading>

<SectionList>
<ColItem>**Next.js** &mdash; the most popular React framework, backed by Vercel. Multiple rendering strategies, massive ecosystem, and the safe default choice.</ColItem>
<ColItem>**React Router Framework Mode** &mdash; React Router v7&apos;s full-stack mode. Built on web standards, progressive enhancement, and vendor independence.</ColItem>
<ColItem>**TanStack Start** &mdash; the newest entry with best-in-class TypeScript support. End-to-end type safety from the TanStack ecosystem.</ColItem>
<ColItem>**Remix** &mdash; the pioneering web-standards framework that merged into React Router v7. Its ideas live on, and understanding it helps you understand modern frameworks.</ColItem>
</SectionList>

<StepJump to="arch-fw-nextjs" label="Start with Next.js" />

<Explainer title="Full-stack frameworks &mdash; a backend analogy">
If stacks are like building a microservice by choosing individual technologies (language, framework, database, message queue), full-stack frameworks are like choosing a platform (Spring Boot, ASP.NET, Rails) that makes the integration decisions for you. You trade some flexibility for a cohesive, well-tested development experience where the pieces are designed to work together.
</Explainer>
