import type { AwsService } from './types'

export const SECURITY_SERVICES: AwsService[] = [
  {
    id: 'iam',
    name: 'IAM',
    fullName: 'Identity and Access Management',
    cat: 'security',
    level: 'beginner',
    icon: '\u{1F511}',
    short: 'Controls WHO can do WHAT in your AWS account. Users, roles, and permissions. The first thing you configure in any AWS account.',
    analogy: 'The keycard system in an office building \u2014 different people get different levels of access to different rooms.',
    detail: 'IAM is how you manage authentication (who are you?) and authorization (what can you do?) in AWS. You create Users (people), Groups (collections of users), Roles (permissions that services or applications assume), and Policies (JSON documents that define permissions). Everything in AWS checks IAM before allowing an action.',
    useCases: [
      'Creating team members with scoped permissions',
      'Allowing your Lambda function to read from S3',
      'Setting up cross-account access',
    ],
    keyTerms: {
      Policy: 'A JSON document defining allowed/denied actions',
      Role: 'A set of permissions that can be assumed by users or services',
      Principal: 'The entity (user, role, service) making a request',
      'Least Privilege': 'Giving only the minimum permissions needed',
    },
    pricing: 'Completely free. Always.',
    code: '// Example IAM Policy (JSON)\n{\n  "Version": "2012-10-17",\n  "Statement": [{\n    "Effect": "Allow",\n    "Action": ["s3:GetObject"],\n    "Resource": "arn:aws:s3:::my-bucket/*"\n  }]\n}\n// This policy allows reading files from my-bucket',
    howItWorks: 'Every single AWS API call goes through IAM for authorization. When your frontend app calls an API backed by Lambda, or when your CI/CD pipeline deploys to S3, IAM evaluates the request against all applicable policies to decide if it should be allowed or denied. Policies are JSON documents that specify Effect (Allow/Deny), Action (which API calls), Resource (which AWS resources), and optional Conditions (IP ranges, time of day, MFA requirements).\n\nIAM uses a "deny by default" model. If no policy explicitly allows an action, it is denied. If any policy explicitly denies an action, it is denied regardless of any allow statements. This is called the "explicit deny wins" rule, and it is the most important concept in IAM to understand. Policies can be attached directly to users (inline), to groups, or to roles. AWS also has managed policies (pre-built by AWS) and customer-managed policies (written by you).\n\nRoles are particularly important for frontend engineers. Instead of embedding AWS credentials in your application code, you assign a role to your Lambda function, ECS task, or EC2 instance. The service automatically receives temporary credentials that rotate every few hours. This is far more secure than long-lived access keys and is the recommended pattern for all service-to-service communication.',
    gotchas: [
      'IAM changes are eventually consistent \u2014 a new policy might take a few seconds to propagate globally. If you grant permission and immediately test, it might still be denied.',
      'Wildcard actions ("s3:*") and resources ("*") are tempting shortcuts but violate least privilege. AWS Access Analyzer can help you scope policies down based on actual usage.',
      'The root user (the email you signed up with) has unrestricted access and cannot be limited by IAM policies. Never use it for daily work \u2014 create IAM users instead and lock the root credentials in a safe.',
      'Policy size limits are real: inline policies max at 2,048 characters, managed policies at 6,144. Complex permission sets often require splitting across multiple policies.',
    ],
    whenNotToUse: [
      'Don\'t use IAM Users for application end-users (humans logging into your app). Use Cognito for that. IAM Users are for developers, CI/CD systems, and administrators.',
      'Don\'t use long-lived IAM access keys in frontend code or client-side applications. They will be exposed. Use Cognito Identity Pools to vend temporary credentials instead.',
      'Don\'t create individual IAM Users for large teams. Use IAM Identity Center (SSO) with your corporate identity provider for organizations with more than a handful of developers.',
    ],
    relatedServices: ['cognito', 'organizations', 'secrets-manager', 'lambda', 'ecs'],
    relatedGuides: ['auth'],
    cliExample: '# Create a new IAM role for a Lambda function\naws iam create-role \\\n  --role-name my-lambda-role \\\n  --assume-role-policy-document \'{\n    "Version": "2012-10-17",\n    "Statement": [{\n      "Effect": "Allow",\n      "Principal": {"Service": "lambda.amazonaws.com"},\n      "Action": "sts:AssumeRole"\n    }]\n  }\'\n\n# Attach a managed policy to the role\naws iam attach-role-policy \\\n  --role-name my-lambda-role \\\n  --policy-arn arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess',
    cdkExample: '// Grant a Lambda function read access to an S3 bucket\nimport * as iam from \'aws-cdk-lib/aws-iam\';\nimport * as lambda from \'aws-cdk-lib/aws-lambda\';\nimport * as s3 from \'aws-cdk-lib/aws-s3\';\n\nconst bucket = new s3.Bucket(this, \'DataBucket\');\n\nconst fn = new lambda.Function(this, \'MyFunction\', {\n  runtime: lambda.Runtime.NODEJS_20_X,\n  handler: \'index.handler\',\n  code: lambda.Code.fromAsset(\'lambda\'),\n});\n\n// CDK creates the IAM policy automatically\nbucket.grantRead(fn);',
  },
  {
    id: 'cognito',
    name: 'Cognito',
    fullName: 'Amazon Cognito',
    cat: 'security',
    level: 'beginner',
    icon: '\u{1F464}',
    short: 'User sign-up, sign-in, and access control for your apps. Think Auth0 or Firebase Auth, but AWS-native.',
    analogy: 'The bouncer and coat check at a club \u2014 verifies your identity, gives you a wristband (token), and remembers your stuff.',
    detail: 'Cognito has two parts: User Pools (authentication \u2014 sign-up/sign-in with email, social logins, MFA) and Identity Pools (authorization \u2014 giving users temporary AWS credentials to access services like S3 directly). For most frontend devs, you\'ll mainly work with User Pools + the Amplify SDK.',
    useCases: [
      'Adding login/signup to your app',
      'Social login (Google, Apple, Facebook)',
      'Securing APIs with JWT tokens',
    ],
    keyTerms: {
      'User Pool': 'A user directory with sign-up/sign-in capabilities',
      'Identity Pool': 'Grants temporary AWS credentials to authenticated users',
      JWT: 'JSON Web Token \u2014 the token Cognito gives authenticated users',
    },
    pricing: 'Free tier: 50,000 MAU (monthly active users) for User Pools. That\'s very generous.',
    code: '// Using Cognito with AWS Amplify (React)\nimport { signIn, signUp } from \'aws-amplify/auth\';\n\nconst user = await signIn({\n  username: \'alice@example.com\',\n  password: \'SecureP@ss1\',\n});\n\nconsole.log(user.signInUserSession.idToken.jwtToken);',
    howItWorks: 'When a user signs up, Cognito stores their credentials in a User Pool (a managed user directory). Passwords are hashed with SRP (Secure Remote Password) protocol, meaning the plaintext password never hits AWS servers. Upon successful authentication, Cognito returns three JWTs: an ID token (user attributes like email and name), an access token (scopes and permissions), and a refresh token (used to get new ID/access tokens without re-authenticating).\n\nUser Pools handle the entire auth lifecycle: sign-up with email verification, password reset flows, MFA (TOTP or SMS), and account recovery. You can customize every email template, add pre/post-authentication Lambda triggers (e.g., to enrich tokens with custom claims or block certain users), and configure password policies. Cognito also supports hosted UI \u2014 a pre-built, customizable login page that handles OAuth flows for you.\n\nIdentity Pools are the bridge between Cognito authentication and AWS authorization. After a user logs in via a User Pool (or Google, Facebook, etc.), the Identity Pool exchanges their token for temporary IAM credentials. This lets your frontend app directly call AWS services like S3 or DynamoDB without a backend proxy. You define two IAM roles \u2014 one for authenticated users and one for unauthenticated (guest) users \u2014 giving you fine-grained control over what each group can access.',
    gotchas: [
      'You cannot change certain User Pool settings after creation (like required attributes, username format, or MFA type). Plan your schema carefully upfront or you will need to migrate users to a new pool.',
      'Cognito tokens expire: ID and access tokens last 1 hour by default (configurable 5 min to 24 hours), refresh tokens last 30 days (configurable). Your frontend must handle token refresh gracefully \u2014 Amplify does this automatically, but custom implementations often miss it.',
      'The hosted UI is quick to set up but limited in customization. For pixel-perfect login pages, use the Amplify SDK to build your own UI and call Cognito APIs directly.',
      'Cognito has a hard limit of 50 custom attributes per User Pool, and you cannot delete attributes once created. Use a separate DynamoDB table for frequently changing user profile data.',
    ],
    whenNotToUse: [
      'If you need machine-to-machine (M2M) authentication without user involvement (e.g., microservice-to-microservice), IAM roles or API keys are a better fit than Cognito.',
      'If your app requires a fully custom authentication flow with complex business logic (multi-tenant auth, organization hierarchies), consider Auth0 or a self-hosted solution like Keycloak for more flexibility.',
      'If you only need to protect AWS resources for developers and CI/CD \u2014 that is IAM\'s job, not Cognito\'s. Cognito is specifically for end-user authentication.',
    ],
    relatedServices: ['iam', 'api-gateway', 'amplify', 'lambda', 'dynamodb'],
    relatedGuides: ['auth'],
    cliExample: '# Create a Cognito User Pool\naws cognito-idp create-user-pool \\\n  --pool-name my-app-users \\\n  --auto-verified-attributes email \\\n  --username-attributes email \\\n  --mfa-configuration OPTIONAL \\\n  --policies \'{"PasswordPolicy":{"MinimumLength":8,"RequireUppercase":true,"RequireLowercase":true,"RequireNumbers":true,"RequireSymbols":false}}\'\n\n# Create an app client (no secret for SPAs)\naws cognito-idp create-user-pool-client \\\n  --user-pool-id us-east-1_abc123 \\\n  --client-name my-spa-client \\\n  --no-generate-secret \\\n  --explicit-auth-flows ALLOW_USER_SRP_AUTH ALLOW_REFRESH_TOKEN_AUTH',
    cdkExample: '// Set up Cognito User Pool with email sign-in\nimport * as cognito from \'aws-cdk-lib/aws-cognito\';\n\nconst userPool = new cognito.UserPool(this, \'AppUserPool\', {\n  selfSignUpEnabled: true,\n  signInAliases: { email: true },\n  autoVerify: { email: true },\n  passwordPolicy: {\n    minLength: 8,\n    requireUppercase: true,\n    requireDigits: true,\n    requireSymbols: false,\n  },\n  mfa: cognito.Mfa.OPTIONAL,\n  mfaSecondFactor: { sms: false, otp: true },\n});\n\n// App client for your SPA (no secret)\nconst client = userPool.addClient(\'SpaClient\', {\n  authFlows: { userSrp: true },\n  oAuth: {\n    flows: { authorizationCodeGrant: true },\n    callbackUrls: [\'https://myapp.com/callback\'],\n  },\n});',
  },
  {
    id: 'secrets-manager',
    name: 'Secrets Manager',
    fullName: 'AWS Secrets Manager',
    cat: 'security',
    level: 'beginner',
    icon: '\u{1F92B}',
    short: 'Stores API keys, database passwords, and other secrets securely. No more .env files in production!',
    analogy: 'A bank vault for your passwords \u2014 only authorized people/services can open the right safety deposit box.',
    detail: 'Secrets Manager stores and automatically rotates secrets like database credentials, API keys, and OAuth tokens. Your app fetches secrets at runtime instead of hardcoding them. It integrates with RDS to automatically rotate database passwords without downtime.',
    useCases: [
      'Storing database credentials',
      'API keys for third-party services',
      'Automatic password rotation',
    ],
    keyTerms: {
      Secret: 'A stored credential (string or JSON)',
      Rotation: 'Automatically changing a secret on a schedule',
    },
    pricing: '$0.40/secret/month + $0.05 per 10,000 API calls.',
    code: '// Fetching a secret in a Lambda function (Node.js)\nimport { SecretsManagerClient, GetSecretValueCommand } from \'@aws-sdk/client-secrets-manager\';\n\nconst client = new SecretsManagerClient({ region: \'us-east-1\' });\n\nconst { SecretString } = await client.send(\n  new GetSecretValueCommand({ SecretId: \'my-app/db-credentials\' })\n);\n\nconst { username, password } = JSON.parse(SecretString!);\nconsole.log(`Connecting as ${username}...`);',
    howItWorks: 'Secrets Manager encrypts your secrets at rest using a KMS key (either the AWS-managed default key or a customer-managed key you specify). When your application needs a secret, it calls the GetSecretValue API. Secrets Manager decrypts the secret using KMS and returns it over a TLS-encrypted connection. The secret plaintext never touches disk on the Secrets Manager side \u2014 it exists only in memory during the API call.\n\nRotation is where Secrets Manager really shines. You configure a rotation schedule (e.g., every 30 days), and Secrets Manager invokes a Lambda function that generates a new credential, updates the target service (like RDS), and stores the new value. For RDS databases, AWS provides pre-built rotation Lambda functions. The rotation uses a "staging label" system: the current secret is labeled AWSCURRENT and the new one is AWSPENDING until rotation completes, ensuring your app always gets a working credential.\n\nFor frontend engineers, the key insight is that your backend code (Lambda functions, ECS tasks) fetches secrets at runtime rather than reading from environment variables baked into your deployment. This means rotating a database password does not require redeploying your application. You should cache secrets in memory for a few minutes to avoid excessive API calls and costs, and the AWS SDK\'s caching client handles this automatically.',
    gotchas: [
      'Secrets Manager costs $0.40/secret/month regardless of size. If you have hundreds of non-sensitive config values, use SSM Parameter Store (free tier available) instead and reserve Secrets Manager for actual secrets that need rotation.',
      'Deleting a secret has a mandatory 7-30 day recovery window. You cannot immediately delete and recreate a secret with the same name. Plan your naming conventions carefully.',
      'Rotation Lambda functions need network access to both Secrets Manager and the target database. If your RDS is in a private subnet, the rotation Lambda needs a VPC configuration and a Secrets Manager VPC endpoint.',
      'Secret values have a 64 KB size limit. Do not store large files or certificates here \u2014 use S3 with KMS encryption for those.',
    ],
    whenNotToUse: [
      'For non-secret configuration (feature flags, app settings, endpoint URLs), use SSM Parameter Store instead. It is free for standard parameters and better suited for config that does not need encryption or rotation.',
      'For client-side secrets in frontend apps (like API keys for public services), Secrets Manager is not the answer \u2014 anything sent to the browser is public. Use API Gateway with a backend proxy to keep secrets server-side.',
      'For temporary session credentials or tokens, use IAM roles and STS (Security Token Service) instead. Secrets Manager is for long-lived credentials, not short-lived temporary ones.',
    ],
    relatedServices: ['kms', 'lambda', 'rds', 'systems-manager', 'iam'],
    relatedGuides: ['security'],
    cliExample: '# Create a new secret (JSON format)\naws secretsmanager create-secret \\\n  --name my-app/db-credentials \\\n  --secret-string \'{"username":"admin","password":"s3cure-p@ss"}\'\n\n# Retrieve the secret value\naws secretsmanager get-secret-value \\\n  --secret-id my-app/db-credentials \\\n  --query SecretString --output text\n\n# Enable automatic rotation (every 30 days)\naws secretsmanager rotate-secret \\\n  --secret-id my-app/db-credentials \\\n  --rotation-lambda-arn arn:aws:lambda:us-east-1:123456789:function:rotate-db \\\n  --rotation-rules AutomaticallyAfterDays=30',
    cdkExample: '// Store a database secret with automatic rotation\nimport * as secretsmanager from \'aws-cdk-lib/aws-secretsmanager\';\nimport * as rds from \'aws-cdk-lib/aws-rds\';\n\n// CDK can generate and manage the secret for you\nconst dbSecret = new secretsmanager.Secret(this, \'DbSecret\', {\n  secretName: \'my-app/db-credentials\',\n  generateSecretString: {\n    secretStringTemplate: JSON.stringify({ username: \'admin\' }),\n    generateStringKey: \'password\',\n    excludePunctuation: true,\n    passwordLength: 32,\n  },\n});\n\n// Attach rotation to an RDS instance\nconst db = new rds.DatabaseInstance(this, \'Database\', {\n  engine: rds.DatabaseInstanceEngine.postgres({ version: rds.PostgresEngineVersion.VER_16 }),\n  credentials: rds.Credentials.fromSecret(dbSecret),\n  /* ... other config ... */\n});\n\ndbSecret.addRotationSchedule(\'Rotation\', {\n  automaticallyAfter: Duration.days(30),\n  hostedRotation: secretsmanager.HostedRotation.postgreSqlSingleUser(),\n});',
  },
  {
    id: 'kms',
    name: 'KMS',
    fullName: 'Key Management Service',
    cat: 'security',
    level: 'intermediate',
    icon: '\u{1F510}',
    short: 'Creates and manages encryption keys. Lets you encrypt data at rest and in transit across AWS services.',
    analogy: 'A master locksmith \u2014 creates, stores, and manages all the locks and keys for your entire operation.',
    detail: 'KMS creates and controls cryptographic keys used to encrypt your data. Many AWS services (S3, EBS, RDS) integrate with KMS to encrypt data automatically. You can also use it to encrypt data in your own applications. Keys never leave KMS \u2014 all encryption/decryption happens inside the service.',
    useCases: [
      'Encrypting S3 buckets',
      'Encrypting database storage',
      'Signing and verifying data in your application',
    ],
    keyTerms: {
      CMK: 'Customer Master Key \u2014 the top-level encryption key',
      'Envelope Encryption': 'Encrypting a data key, which encrypts your actual data',
    },
    pricing: '$1.00/key/month. $0.03 per 10,000 API calls.',
    code: '// Encrypting and decrypting data with KMS (Node.js)\nimport { KMSClient, EncryptCommand, DecryptCommand } from \'@aws-sdk/client-kms\';\n\nconst kms = new KMSClient({ region: \'us-east-1\' });\n\n// Encrypt\nconst { CiphertextBlob } = await kms.send(new EncryptCommand({\n  KeyId: \'alias/my-app-key\',\n  Plaintext: Buffer.from(\'sensitive-data\'),\n}));\n\n// Decrypt\nconst { Plaintext } = await kms.send(new DecryptCommand({\n  CiphertextBlob,\n}));\nconsole.log(Buffer.from(Plaintext!).toString()); // "sensitive-data"',
    howItWorks: 'KMS manages cryptographic keys inside FIPS 140-2 validated hardware security modules (HSMs). When you create a KMS key, the key material is generated and stored exclusively within these HSMs \u2014 it can never be exported or extracted. When you call the Encrypt API, your plaintext data (up to 4 KB) is sent to KMS, encrypted inside the HSM, and the ciphertext is returned. Decryption works the same way in reverse.\n\nFor data larger than 4 KB (which is most real-world data), KMS uses envelope encryption. Instead of sending your entire file to KMS, you call GenerateDataKey. KMS returns a plaintext data key AND an encrypted copy of that key. Your application uses the plaintext key to encrypt the data locally (using AES-256), then stores the encrypted data alongside the encrypted data key. To decrypt later, you send the encrypted data key to KMS, get back the plaintext key, and use it to decrypt your data locally. This way, KMS only handles the small key, not your potentially gigabyte-sized data.\n\nMost AWS services handle this transparently. When you enable SSE-KMS on an S3 bucket, S3 automatically calls KMS to generate data keys, encrypts each object, and stores the encrypted key as object metadata. You never see this happening \u2014 your app just calls PutObject and GetObject normally. The only visible difference is that the calling IAM role needs kms:Decrypt permission on the KMS key, which trips up many frontend engineers deploying their first encrypted infrastructure.',
    gotchas: [
      'KMS has a request rate limit (typically 5,500-30,000 requests/second depending on region and key type). If your app decrypts on every request, you can hit throttling. Cache decrypted data keys in memory using the AWS Encryption SDK.',
      'Deleting a KMS key is irreversible and has a mandatory 7-30 day waiting period. If the key is deleted, all data encrypted with it becomes permanently unrecoverable. Always use key aliases and disable keys before considering deletion.',
      'Cross-region encryption requires separate KMS keys in each region \u2014 KMS keys are region-specific. If you replicate S3 data across regions, each region needs its own key with appropriate policies.',
      'KMS key policies and IAM policies work together, but KMS key policies are the primary gatekeeper. Even if an IAM policy allows kms:Decrypt, the KMS key policy must also grant access. Forgetting to update the key policy is a common source of "AccessDenied" errors.',
    ],
    whenNotToUse: [
      'For hashing passwords (like user login credentials), use bcrypt or Argon2 instead. KMS is for symmetric/asymmetric encryption, not password hashing \u2014 these are different cryptographic operations.',
      'For managing TLS/SSL certificates, use ACM (Certificate Manager) instead. KMS manages raw encryption keys, not X.509 certificates.',
      'If you only need basic server-side encryption on S3, you can use SSE-S3 (S3-managed keys) instead of SSE-KMS. It is simpler, has no per-request charges, and is sufficient when you do not need key-level access control or audit trails.',
    ],
    relatedServices: ['secrets-manager', 's3', 'rds', 'ebs', 'certificate-manager'],
    relatedGuides: ['security'],
    cliExample: '# Create a symmetric encryption key\naws kms create-key \\\n  --description "My app encryption key" \\\n  --key-usage ENCRYPT_DECRYPT\n\n# Create a friendly alias\naws kms create-alias \\\n  --alias-name alias/my-app-key \\\n  --target-key-id <key-id-from-above>\n\n# Encrypt a value\naws kms encrypt \\\n  --key-id alias/my-app-key \\\n  --plaintext "sensitive-data" \\\n  --output text --query CiphertextBlob',
    cdkExample: '// Create a KMS key and use it to encrypt an S3 bucket\nimport * as kms from \'aws-cdk-lib/aws-kms\';\nimport * as s3 from \'aws-cdk-lib/aws-s3\';\n\nconst encryptionKey = new kms.Key(this, \'AppKey\', {\n  alias: \'my-app-key\',\n  description: \'Encrypts application data\',\n  enableKeyRotation: true, // Rotates key material annually\n});\n\nconst bucket = new s3.Bucket(this, \'EncryptedBucket\', {\n  encryptionKey,\n  encryption: s3.BucketEncryption.KMS,\n  enforceSSL: true,\n});\n\n// Grant a Lambda function permission to decrypt\nencryptionKey.grantDecrypt(myLambdaFunction);',
  },
  {
    id: 'waf',
    name: 'WAF',
    fullName: 'Web Application Firewall',
    cat: 'security',
    level: 'intermediate',
    icon: '\u{1F6E1}\uFE0F',
    short: 'Protects your web apps from common attacks like SQL injection, XSS, and DDoS. Sits in front of CloudFront or ALB.',
    analogy: 'A security guard who inspects every person entering the building and blocks known troublemakers.',
    detail: 'WAF lets you create rules that filter web traffic. You can block requests based on IP addresses, HTTP headers, URI strings, SQL injection patterns, or cross-site scripting patterns. AWS also provides managed rule groups for common threats (OWASP Top 10, known bad IPs, etc.).',
    useCases: [
      'Blocking SQL injection and XSS attacks',
      'Rate limiting to prevent abuse',
      'Geo-blocking (restrict access by country)',
      'Bot detection',
    ],
    keyTerms: {
      'Web ACL': 'A set of rules applied to your traffic',
      'Rule Group': 'A reusable collection of rules',
      'Managed Rules': 'Pre-built rule sets maintained by AWS or third parties',
    },
    pricing: '$5/web ACL/month + $1/rule/month + $0.60/million requests.',
    code: '// WAF is configured via infrastructure, not app code.\n// Here\'s how to check if a request was blocked (in your logs):\n\n// CloudWatch Logs for WAF show:\n// {\n//   "action": "BLOCK",\n//   "terminatingRuleId": "AWS-AWSManagedRulesSQLiRuleSet",\n//   "httpRequest": {\n//     "uri": "/api/users?id=1 OR 1=1",\n//     "method": "GET"\n//   }\n// }\n\n// In your frontend, a blocked request returns HTTP 403\ntry {\n  const res = await fetch(\'/api/data\');\n  if (res.status === 403) {\n    console.log(\'Request blocked by WAF\');\n  }\n} catch (err) {\n  // Handle network error\n}',
    howItWorks: 'WAF evaluates every HTTP/HTTPS request that hits your CloudFront distribution, Application Load Balancer, API Gateway, or AppSync API. It processes requests through a Web ACL (Access Control List) containing an ordered list of rules. Each rule inspects a specific part of the request \u2014 the URI path, query string, headers, body, or IP address \u2014 and takes an action: Allow, Block, Count (monitor without blocking), or CAPTCHA.\n\nRules are evaluated in priority order (lowest number first). The first rule that matches determines the action. If no rule matches, the Web ACL\'s default action applies (typically Allow). This priority system lets you create nuanced policies: for example, always allow your office IP (priority 1), block known bad IPs (priority 2), apply rate limiting (priority 3), and run managed rule groups for SQL injection and XSS detection (priority 4-10).\n\nAWS Managed Rules are the fastest way to protect your app. The "Core Rule Set" covers OWASP Top 10 vulnerabilities, "Known Bad Inputs" blocks common exploit patterns, and "Bot Control" identifies and manages bot traffic. You can also add third-party rule sets from the AWS Marketplace (like those from Fortinet or Imperva). For frontend engineers, the most impactful rules are rate-based rules (preventing API abuse), the SQL injection rule set (protecting your backend), and geo-match rules (compliance with data residency requirements).',
    gotchas: [
      'WAF rules have a WCU (Web ACL Capacity Unit) limit of 5,000 per Web ACL. Managed rule groups consume significant WCU \u2014 the Core Rule Set alone uses 700 WCU. Plan your rule budget carefully.',
      'WAF can only inspect the first 8 KB of a request body by default (16 KB with the extended option at extra cost). Large POST bodies or file uploads may bypass body-inspection rules. Validate inputs in your application code as a second layer of defense.',
      'Rate-based rules have a minimum threshold of 100 requests per 5-minute window. If you need stricter rate limiting (e.g., 10 requests/minute for a login endpoint), implement it in your application or use API Gateway throttling.',
      'WAF logging to CloudWatch, S3, or Firehose must be explicitly enabled and the log destination name must start with "aws-waf-logs-". Missing this naming convention is a common deployment error.',
    ],
    whenNotToUse: [
      'WAF does not replace input validation in your application code. It catches common attack patterns, but sophisticated or application-specific attacks need server-side validation. Use WAF as a first line of defense, not the only one.',
      'For DDoS protection at the network layer (Layer 3/4), use AWS Shield instead. WAF operates at the application layer (Layer 7) and does not protect against volumetric network floods.',
      'If your API is internal (service-to-service within a VPC), WAF adds unnecessary cost and latency. Use security groups and IAM authorization for internal traffic instead.',
    ],
    relatedServices: ['cloudfront', 'elb', 'api-gateway', 'certificate-manager', 'route53'],
    relatedGuides: ['security'],
    cliExample: '# Create a Web ACL with the AWS Core Rule Set\naws wafv2 create-web-acl \\\n  --name my-app-waf \\\n  --scope REGIONAL \\\n  --default-action Allow={} \\\n  --visibility-config SampledRequestsEnabled=true,CloudWatchMetricsEnabled=true,MetricName=myAppWaf \\\n  --rules \'[{\n    "Name": "AWSCoreRuleSet",\n    "Priority": 1,\n    "Statement": {\n      "ManagedRuleGroupStatement": {\n        "VendorName": "AWS",\n        "Name": "AWSManagedRulesCommonRuleSet"\n      }\n    },\n    "OverrideAction": {"None": {}},\n    "VisibilityConfig": {\n      "SampledRequestsEnabled": true,\n      "CloudWatchMetricsEnabled": true,\n      "MetricName": "coreRuleSet"\n    }\n  }]\'\n\n# Associate with an ALB\naws wafv2 associate-web-acl \\\n  --web-acl-arn <web-acl-arn> \\\n  --resource-arn <alb-arn>',
    cdkExample: '// Create a WAF Web ACL with managed rules for a CloudFront distribution\nimport * as wafv2 from \'aws-cdk-lib/aws-wafv2\';\n\nconst webAcl = new wafv2.CfnWebACL(this, \'AppWaf\', {\n  defaultAction: { allow: {} },\n  scope: \'CLOUDFRONT\', // Use \'REGIONAL\' for ALB\n  visibilityConfig: {\n    cloudWatchMetricsEnabled: true,\n    sampledRequestsEnabled: true,\n    metricName: \'appWaf\',\n  },\n  rules: [\n    {\n      name: \'AWSCoreRuleSet\',\n      priority: 1,\n      statement: {\n        managedRuleGroupStatement: {\n          vendorName: \'AWS\',\n          name: \'AWSManagedRulesCommonRuleSet\',\n        },\n      },\n      overrideAction: { none: {} },\n      visibilityConfig: {\n        cloudWatchMetricsEnabled: true,\n        sampledRequestsEnabled: true,\n        metricName: \'coreRules\',\n      },\n    },\n    {\n      name: \'RateLimit\',\n      priority: 2,\n      statement: {\n        rateBasedStatement: {\n          limit: 2000, // Max 2000 requests per 5 min per IP\n          aggregateKeyType: \'IP\',\n        },\n      },\n      action: { block: {} },\n      visibilityConfig: {\n        cloudWatchMetricsEnabled: true,\n        sampledRequestsEnabled: true,\n        metricName: \'rateLimit\',\n      },\n    },\n  ],\n});',
  },
  {
    id: 'certificate-manager',
    name: 'ACM',
    fullName: 'AWS Certificate Manager',
    cat: 'security',
    level: 'beginner',
    icon: '\u{1F4DC}',
    short: 'Free SSL/TLS certificates for your domains. Enables HTTPS on your websites with automatic renewal.',
    analogy: 'A free, auto-renewing padlock for your website\'s front door that proves you are who you say you are.',
    detail: 'ACM provisions and manages SSL/TLS certificates for your AWS resources. Certificates are completely free when used with CloudFront, ALB, or API Gateway. ACM handles renewal automatically \u2014 no more expired certificates breaking your site at 3 AM.',
    useCases: [
      'Enabling HTTPS on your website',
      'Securing APIs',
      'Email encryption with SES',
    ],
    keyTerms: {
      'SSL/TLS Certificate': 'A digital certificate that enables HTTPS encryption',
      'DNS Validation': 'Proving you own a domain by adding a DNS record',
    },
    pricing: 'Free for public certificates used with AWS services.',
    code: '// ACM is infrastructure configuration, not application code.\n// Here\'s how you reference an ACM cert in your CDK/CloudFormation:\n\n// In CDK (TypeScript):\nimport * as acm from \'aws-cdk-lib/aws-certificatemanager\';\n\nconst cert = acm.Certificate.fromCertificateArn(\n  this, \'Cert\',\n  \'arn:aws:acm:us-east-1:123456789:certificate/abc-123\'\n);\n\n// Then attach to CloudFront, ALB, or API Gateway\n// distribution.addBehavior(\'/*\', origin, { certificate: cert });',
    howItWorks: 'When you request a certificate, ACM needs to verify that you own the domain. You choose one of two validation methods: DNS validation (recommended) or email validation. For DNS validation, ACM gives you a CNAME record to add to your domain\'s DNS. Once the record is detected, ACM issues the certificate. If you use Route 53 for DNS, this can be fully automated with a single click or API call.\n\nACM certificates use the X.509 standard and support both RSA 2048-bit and ECDSA P-256 key algorithms. Each certificate can cover multiple domains using Subject Alternative Names (SANs) \u2014 so one certificate can protect "example.com", "*.example.com", and "api.example.com". Wildcard certificates (*.example.com) cover all first-level subdomains, which is ideal for multi-tenant SaaS applications.\n\nRenewal is fully automatic. ACM begins attempting renewal 60 days before expiration. For DNS-validated certificates, renewal is seamless as long as the CNAME record still exists. For email-validated certificates, ACM sends renewal emails to the domain owner. The renewed certificate uses the same ARN, so your CloudFront distributions and load balancers pick up the new certificate automatically without any configuration changes or downtime.',
    gotchas: [
      'CloudFront requires certificates to be in us-east-1 (N. Virginia), regardless of where your other resources are. ALB certificates must be in the same region as the load balancer. This is the most common ACM mistake for frontend engineers.',
      'ACM certificates cannot be exported or used outside of AWS-integrated services. If you need a certificate for an on-premise server or a non-AWS service, you need to use a different CA or import your own certificate into ACM.',
      'DNS validation CNAME records must stay in your DNS forever (not just during initial validation). ACM uses them for automatic renewal. Removing them causes renewal to fail silently until your certificate expires.',
      'Certificate provisioning can take up to 30 minutes after DNS validation records propagate. In CI/CD pipelines, you may need to request certificates in a separate stack or add wait logic.',
    ],
    whenNotToUse: [
      'If you need certificates for servers outside of AWS (on-premise, other cloud providers, local development), use Let\'s Encrypt or a traditional CA. ACM certificates are locked to AWS services.',
      'For mutual TLS (mTLS) where the client must present a certificate to the server, ACM alone is not sufficient. You need to use ACM Private CA, which has a significant cost ($400/month per CA).',
      'If you need Extended Validation (EV) certificates (the ones that used to show the green company name in browsers), ACM only issues Domain Validation (DV) certificates. Use a traditional CA for EV certs.',
    ],
    relatedServices: ['cloudfront', 'elb', 'api-gateway', 'route53', 'waf'],
    relatedGuides: ['security'],
    cliExample: '# Request a certificate with DNS validation\naws acm request-certificate \\\n  --domain-name example.com \\\n  --subject-alternative-names "*.example.com" \\\n  --validation-method DNS \\\n  --key-algorithm RSA_2048\n\n# Describe the certificate to get DNS validation records\naws acm describe-certificate \\\n  --certificate-arn arn:aws:acm:us-east-1:123456789:certificate/abc-123 \\\n  --query "Certificate.DomainValidationOptions[].ResourceRecord"\n\n# List all certificates\naws acm list-certificates \\\n  --certificate-statuses ISSUED',
    cdkExample: '// Create and validate an ACM certificate with Route 53\nimport * as acm from \'aws-cdk-lib/aws-certificatemanager\';\nimport * as route53 from \'aws-cdk-lib/aws-route53\';\nimport * as cloudfront from \'aws-cdk-lib/aws-cloudfront\';\n\nconst hostedZone = route53.HostedZone.fromLookup(this, \'Zone\', {\n  domainName: \'example.com\',\n});\n\n// Certificate with automatic DNS validation\nconst certificate = new acm.Certificate(this, \'SiteCert\', {\n  domainName: \'example.com\',\n  subjectAlternativeNames: [\'*.example.com\'],\n  validation: acm.CertificateValidation.fromDns(hostedZone),\n});\n\n// Use with a CloudFront distribution\nconst distribution = new cloudfront.Distribution(this, \'Dist\', {\n  defaultBehavior: { origin: myOrigin },\n  domainNames: [\'example.com\', \'www.example.com\'],\n  certificate,\n});',
  },
  {
    id: 'organizations',
    name: 'Organizations',
    fullName: 'AWS Organizations',
    cat: 'security',
    level: 'advanced',
    icon: '\u{1F3E2}',
    short: 'Manage multiple AWS accounts as one unit. Centralize billing, enforce policies, and isolate workloads across accounts.',
    analogy: 'A corporate headquarters that manages branch offices \u2014 sets company-wide policies while each office (account) runs independently.',
    detail: 'Organizations lets you create and centrally manage multiple AWS accounts. You can group accounts into OUs (Organizational Units), apply Service Control Policies (SCPs) to restrict what accounts can do, and consolidate billing. Best practice is separate accounts for dev/staging/prod.',
    useCases: [
      'Multi-account strategy for enterprise AWS',
      'Centralized billing',
      'Enforcing security guardrails across accounts',
    ],
    keyTerms: {
      OU: 'Organizational Unit \u2014 a group of accounts',
      SCP: 'Service Control Policy \u2014 limits what accounts can do',
      'Management Account': 'The root/master account that manages others',
    },
    pricing: 'Free.',
    code: '// Organizations is managed through infrastructure, not app code.\n// Here\'s an example SCP that prevents disabling CloudTrail:\n{\n  "Version": "2012-10-17",\n  "Statement": [{\n    "Sid": "ProtectCloudTrail",\n    "Effect": "Deny",\n    "Action": [\n      "cloudtrail:StopLogging",\n      "cloudtrail:DeleteTrail"\n    ],\n    "Resource": "*"\n  }]\n}\n\n// This SCP, attached to an OU, prevents ANY account\n// in that OU from disabling audit logging \u2014 even admins.',
    howItWorks: 'AWS Organizations creates a hierarchy with a management account (the root) at the top, Organizational Units (OUs) as branches, and member accounts as leaves. The management account has special privileges: it creates and invites accounts, manages the OU structure, and attaches Service Control Policies. Member accounts operate independently but are subject to the SCPs applied to their OU.\n\nService Control Policies (SCPs) are the enforcement mechanism. Unlike IAM policies that grant permissions, SCPs set the maximum permissions boundary for an entire account. If an SCP denies an action, no IAM user, role, or even the account root user can perform it. This is incredibly powerful for security guardrails. Common SCPs include: preventing accounts from leaving the organization, requiring all S3 buckets to be encrypted, restricting which AWS regions can be used, and blocking the deletion of audit trails.\n\nFor frontend engineers working in organizations, the practical impact is that your AWS account might not have access to every AWS service or region. If you get an "Access Denied" error that your IAM permissions do not explain, an SCP might be the cause. Organizations also enables consolidated billing, meaning your team\'s dev account benefits from the volume discounts earned across the entire organization. AWS Control Tower builds on top of Organizations to provide a pre-configured multi-account setup with best-practice guardrails, making it easier to get started without designing the OU structure from scratch.',
    gotchas: [
      'The management account is NOT subject to SCPs. Never run workloads in the management account \u2014 use it exclusively for organization management. A compromised management account means a compromised entire organization.',
      'SCPs do not grant permissions; they only restrict them. An account still needs IAM policies to allow actions. SCPs set the ceiling, IAM policies set the actual permissions within that ceiling. This confuses many people who attach an SCP "Allow" statement and expect it to grant access.',
      'Moving an account between OUs immediately applies the new OU\'s SCPs. This can instantly break running workloads if the new OU has more restrictive policies. Always test SCP changes with the "Deny" effect on a sandbox account first.',
      'You cannot remove an account from an organization if it does not have a valid payment method (credit card). AWS requires standalone accounts to have their own billing. Plan account exits carefully during reorganizations.',
    ],
    whenNotToUse: [
      'For small teams or personal projects with a single AWS account, Organizations adds unnecessary complexity. You only need it when you have multiple accounts to manage or compliance requirements that demand account isolation.',
      'Do not use Organizations solely for billing separation. AWS billing supports cost allocation tags within a single account, which may be sufficient for tracking costs by project or team without the overhead of multiple accounts.',
      'If you need to share resources between accounts frequently (e.g., a shared VPC or database), Organizations alone does not solve this. You will also need AWS Resource Access Manager (RAM) or cross-account IAM roles, which add complexity.',
    ],
    relatedServices: ['iam', 'cloudtrail', 'config', 'cloudformation'],
    relatedGuides: ['security'],
    cliExample: '# Create a new Organization\naws organizations create-organization \\\n  --feature-set ALL\n\n# Create an Organizational Unit\naws organizations create-organizational-unit \\\n  --parent-id r-abc1 \\\n  --name Production\n\n# Create a new member account\naws organizations create-account \\\n  --email prod-team@example.com \\\n  --account-name "Production Workloads"\n\n# Attach an SCP to an OU\naws organizations attach-policy \\\n  --policy-id p-abc123 \\\n  --target-id ou-abc1-def234',
    cdkExample: '// Organizations is typically managed outside CDK,\n// but you can create SCPs and OUs with CDK:\nimport * as organizations from \'aws-cdk-lib/aws-organizations\';\n\n// Create an OU under the root\nconst prodOU = new organizations.CfnOrganizationalUnit(this, \'ProdOU\', {\n  name: \'Production\',\n  parentId: \'r-abc1\', // Organization root ID\n});\n\n// Create an SCP that enforces encryption\nconst encryptionPolicy = new organizations.CfnPolicy(this, \'RequireEncryption\', {\n  name: \'RequireS3Encryption\',\n  type: \'SERVICE_CONTROL_POLICY\',\n  targetIds: [prodOU.attrId],\n  content: JSON.stringify({\n    Version: \'2012-10-17\',\n    Statement: [{\n      Sid: \'DenyUnencryptedS3\',\n      Effect: \'Deny\',\n      Action: \'s3:PutObject\',\n      Resource: \'*\',\n      Condition: {\n        StringNotEquals: {\n          \'s3:x-amz-server-side-encryption\': \'aws:kms\',\n        },\n      },\n    }],\n  }),\n});',
  },
]
