import type { AwsService } from './types'

export const DEVTOOLS_SERVICES: AwsService[] = [
  {
    id: 'codepipeline',
    name: 'CodePipeline',
    fullName: 'AWS CodePipeline',
    cat: 'devtools',
    level: 'intermediate',
    icon: '\u{1F504}',
    short: 'Automated CI/CD pipelines. Automatically build, test, and deploy your code when you push changes.',
    analogy: 'A factory assembly line \u2014 raw materials (code) go in one end, finished products (deployed apps) come out the other, automatically.',
    detail: 'CodePipeline orchestrates your release process. You define stages: Source (pull from GitHub/CodeCommit), Build (run tests, compile), and Deploy (push to ECS, S3, Lambda, etc.). Each stage can use AWS tools (CodeBuild, CodeDeploy) or third-party tools (Jenkins, GitHub Actions).',
    useCases: [
      'Automating deployments on git push',
      'Multi-stage release pipelines',
      'Approval gates before production deploys',
    ],
    keyTerms: {
      Stage: 'A step in the pipeline (Source \u2192 Build \u2192 Deploy)',
      Action: 'A specific task within a stage',
      Artifact: 'Output from one stage that feeds into the next (e.g., a build zip)',
    },
    pricing: 'Free tier: 1 active pipeline/month. After: $1/active pipeline/month.',
  },
  {
    id: 'codebuild',
    name: 'CodeBuild',
    fullName: 'AWS CodeBuild',
    cat: 'devtools',
    level: 'intermediate',
    icon: '\u{1F3D7}\uFE0F',
    short: 'A managed build service. Compiles code, runs tests, and produces deployment packages. Like GitHub Actions runners, but on AWS.',
    analogy: 'A construction crew you hire per job \u2014 they show up, build what you need, clean up, and leave.',
    detail: 'CodeBuild spins up a build environment (a container), runs your build commands (npm install, npm test, npm run build), and produces artifacts. You don\'t manage servers. It reads a buildspec.yml file in your repo that defines what to do.',
    useCases: [
      'Running tests on every commit',
      'Building Docker images',
      'Compiling and packaging applications',
    ],
    keyTerms: {
      'buildspec.yml': 'A YAML file that defines build commands',
      'Build Environment': 'The Docker image used for building (Ubuntu, Amazon Linux, etc.)',
    },
    pricing: 'Free tier: 100 build minutes/month. After: ~$0.005/build minute for small instances.',
    code: '# buildspec.yml example\nversion: 0.2\nphases:\n  install:\n    commands:\n      - npm ci\n  build:\n    commands:\n      - npm test\n      - npm run build\nartifacts:\n  files:\n    - \'build/**/*\'',
  },
  {
    id: 'cloudformation',
    name: 'CloudFormation',
    fullName: 'AWS CloudFormation',
    cat: 'devtools',
    level: 'intermediate',
    icon: '\u{1F4D0}',
    short: 'Infrastructure as Code (IaC). Define your entire AWS infrastructure in JSON/YAML templates, and deploy it all at once.',
    analogy: 'Blueprints for a building \u2014 hand the architect (CloudFormation) a blueprint, and they construct everything to spec. Tear it down and rebuild identically anytime.',
    detail: 'CloudFormation lets you define AWS resources (EC2 instances, S3 buckets, Lambda functions, databases) in a template file. When you deploy the template, CloudFormation creates all resources in the right order, handles dependencies, and can roll back if something fails. This is "Infrastructure as Code" \u2014 your infrastructure is version-controlled and reproducible.',
    useCases: [
      'Reproducible environments (dev/staging/prod from same template)',
      'Automated infrastructure deployment',
      'Disaster recovery (rebuild everything from a template)',
    ],
    keyTerms: {
      Stack: 'A deployed instance of a template',
      Template: 'The JSON/YAML file defining resources',
      'Drift Detection': 'Checking if actual resources differ from the template',
    },
    pricing: 'Free for AWS resources. Charges only for the resources you create.',
  },
  {
    id: 'cdk',
    name: 'CDK',
    fullName: 'Cloud Development Kit',
    cat: 'devtools',
    level: 'intermediate',
    icon: '\u{1F9F1}',
    short: 'Define cloud infrastructure using real programming languages (TypeScript, Python, Java) instead of YAML. Compiles down to CloudFormation.',
    analogy: 'If CloudFormation is writing blueprints by hand, CDK is using a 3D modeling program that generates blueprints for you.',
    detail: 'CDK lets you define infrastructure using familiar languages. Instead of writing 200 lines of YAML, you write 20 lines of TypeScript. CDK "synthesizes" your code into CloudFormation templates. It includes high-level "constructs" that bundle best practices \u2014 e.g., a single line can create a Lambda + API Gateway + IAM role with correct permissions.',
    useCases: [
      'Teams that prefer TypeScript/Python over YAML',
      'Complex infrastructure with loops, conditions, and abstractions',
      'Sharing reusable infrastructure patterns',
    ],
    keyTerms: {
      Construct: 'A building block representing one or more AWS resources',
      Stack: 'A deployable unit of infrastructure',
      Synthesize: 'Converting CDK code to a CloudFormation template',
    },
    pricing: 'Free. You pay for the resources deployed.',
    code: '// CDK: Create an S3 bucket + CloudFront in TypeScript\nimport * as cdk from \'aws-cdk-lib\';\nimport * as s3 from \'aws-cdk-lib/aws-s3\';\nimport * as cf from \'aws-cdk-lib/aws-cloudfront\';\n\nconst bucket = new s3.Bucket(this, \'Site\');\nnew cf.Distribution(this, \'CDN\', {\n  defaultBehavior: { origin: new origins.S3Origin(bucket) },\n});',
  },
  {
    id: 'sam',
    name: 'SAM',
    fullName: 'Serverless Application Model',
    cat: 'devtools',
    level: 'intermediate',
    icon: '\u{1F43F}\uFE0F',
    short: 'A framework for building serverless apps. Simplifies defining Lambda functions, APIs, and databases in a template.',
    analogy: 'A recipe card specifically for serverless dishes \u2014 fewer ingredients (config) needed than the full cookbook (CloudFormation).',
    detail: 'SAM is a CloudFormation extension that adds shorthand syntax for serverless resources. Instead of 50+ lines of CloudFormation to define a Lambda + API Gateway, SAM does it in ~10 lines. It includes a local development tool (sam local) that simulates Lambda on your machine for testing.',
    useCases: [
      'Building serverless APIs',
      'Local testing of Lambda functions',
      'Deploying serverless applications',
    ],
    keyTerms: {
      'SAM Template': 'A simplified CloudFormation template with serverless shortcuts',
      'sam local': 'CLI tool to run Lambda locally',
      'AWS::Serverless::Function': 'SAM resource type for Lambda',
    },
    pricing: 'Free. You pay for the resources deployed.',
  },
  {
    id: 'cloudshell',
    name: 'CloudShell',
    fullName: 'AWS CloudShell',
    cat: 'devtools',
    level: 'beginner',
    icon: '\u{1F4BB}',
    short: 'A browser-based shell pre-configured with AWS CLI and common tools. Run AWS commands without installing anything.',
    analogy: 'A fully equipped workshop that appears in your browser \u2014 all the tools are already on the workbench.',
    detail: 'CloudShell gives you a Linux terminal directly in the AWS console. It comes pre-installed with AWS CLI, Python, Node.js, and other common tools. Your home directory persists (1 GB) between sessions. It\'s free and great for quick tasks, exploration, and learning.',
    useCases: [
      'Running quick AWS CLI commands',
      'Learning and experimenting with AWS',
      'Scripts that don\'t need a full development environment',
    ],
    keyTerms: {
      'Persistent Storage': '1 GB of storage that survives between sessions',
    },
    pricing: 'Free.',
  },
]
