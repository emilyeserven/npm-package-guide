import type { AwsService } from './types'

export const SERVERLESS_SERVICES: AwsService[] = [
  {
    id: 'lambda',
    name: 'Lambda',
    fullName: 'AWS Lambda',
    cat: 'serverless',
    level: 'beginner',
    icon: '\u03BB',
    short: 'Run code without managing servers. Upload a function, and AWS runs it whenever something triggers it (an API call, a file upload, a timer).',
    analogy: 'A vending machine \u2014 you don\'t run the factory, you just press a button and get your snack. It sits idle until needed.',
    detail: 'Lambda is THE serverless service. You write a function (in JS, Python, Go, etc.), upload it, and define what triggers it. AWS handles all the servers, scaling, and availability. You pay only for the milliseconds your code actually runs. If nobody calls your function, you pay nothing.',
    useCases: [
      'API endpoints (paired with API Gateway)',
      'Processing uploaded images (resize, thumbnail)',
      'Running cron jobs / scheduled tasks',
      'Reacting to database changes',
    ],
    keyTerms: {
      Trigger: 'An event that causes your function to run',
      'Cold Start': 'A slight delay when Lambda spins up a new container for your function',
      Runtime: 'The language environment (Node.js 20.x, Python 3.12, etc.)',
    },
    pricing: 'Free tier: 1M requests + 400,000 GB-seconds/month. This is very generous \u2014 many small apps run free forever.',
    code: '// A Lambda function (Node.js)\nexport const handler = async (event) => {\n  const name = event.queryStringParameters?.name || \'World\';\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ message: `Hello, ${name}!` }),\n  };\n};',
  },
  {
    id: 'step-functions',
    name: 'Step Functions',
    fullName: 'AWS Step Functions',
    cat: 'serverless',
    level: 'intermediate',
    icon: '\u{1F500}',
    short: 'Visual workflow orchestration. Chain Lambda functions and AWS services into complex workflows with branching, retries, and error handling.',
    analogy: 'A flowchart that actually runs \u2014 draw the steps, connect them with arrows, and AWS executes the whole thing.',
    detail: 'Step Functions lets you build workflows as state machines. Each "state" can invoke a Lambda function, call an AWS service, wait, branch based on conditions, run tasks in parallel, or handle errors. You define the workflow in Amazon States Language (JSON), and the visual console shows it as a flowchart.',
    useCases: [
      'Order processing (validate \u2192 charge \u2192 ship \u2192 notify)',
      'Data processing pipelines',
      'Human approval workflows',
      'Error handling and retry logic',
    ],
    keyTerms: {
      'State Machine': 'The complete workflow definition',
      State: 'A single step in the workflow',
      'Task State': 'A state that does work (calls Lambda, etc.)',
    },
    pricing: 'Standard: $0.025/1000 state transitions. Express: $1.00/million requests.',
  },
  {
    id: 'eventbridge',
    name: 'EventBridge',
    fullName: 'Amazon EventBridge',
    cat: 'serverless',
    level: 'intermediate',
    icon: '\u{1F4E1}',
    short: 'A serverless event bus. Routes events between your services and third-party SaaS apps based on rules you define.',
    analogy: 'A post office sorting machine \u2014 events come in, get matched to rules, and delivered to the right mailboxes.',
    detail: 'EventBridge is the central nervous system for event-driven architectures. Services emit events (user signed up, order placed, file uploaded), and EventBridge routes them to targets (Lambda, SQS, Step Functions) based on pattern-matching rules. It also integrates with SaaS apps like Stripe, Auth0, and Zendesk.',
    useCases: [
      'Decoupling microservices with events',
      'Reacting to changes across services',
      'Scheduling tasks (cron-like)',
    ],
    keyTerms: {
      'Event Bus': 'A channel that receives events',
      Rule: 'A pattern that matches events and routes them',
      Target: 'Where matched events are delivered (Lambda, SQS, etc.)',
    },
    pricing: 'Free for AWS service events. Custom events: $1.00/million.',
  },
  {
    id: 'sqs',
    name: 'SQS',
    fullName: 'Simple Queue Service',
    cat: 'serverless',
    level: 'beginner',
    icon: '\u{1F4EC}',
    short: 'A message queue. One service puts messages in, another takes them out. Decouples your services so they don\'t need to talk directly.',
    analogy: 'A to-do inbox \u2014 one person drops tasks in, another picks them up when they\'re ready. If the reader is on break, the tasks just wait.',
    detail: 'SQS is a fully managed message queue. Service A sends a message to the queue, and Service B polls the queue and processes messages at its own pace. If Service B crashes, messages stay in the queue until it comes back. This prevents one slow service from crashing everything else.',
    useCases: [
      'Decoupling a web server from background job processing',
      'Buffering writes to a database',
      'Distributing work across multiple workers',
    ],
    keyTerms: {
      'Standard Queue': 'Best-effort ordering, at-least-once delivery',
      'FIFO Queue': 'Guaranteed order, exactly-once processing',
      'Visibility Timeout': 'How long a message is hidden after being read (while being processed)',
      'Dead Letter Queue': 'Where failed messages go after too many processing attempts',
    },
    pricing: 'Free tier: 1M requests/month (forever). After: $0.40/million requests.',
  },
  {
    id: 'sns',
    name: 'SNS',
    fullName: 'Simple Notification Service',
    cat: 'serverless',
    level: 'beginner',
    icon: '\u{1F4E2}',
    short: 'Pub/sub messaging. One message goes out, multiple subscribers get it. Perfect for fan-out patterns.',
    analogy: 'A group chat \u2014 one person posts a message, and everyone in the group sees it.',
    detail: 'SNS uses a publish/subscribe model. You create a "topic," services publish messages to it, and all subscribers (Lambda functions, SQS queues, email addresses, HTTP endpoints) receive a copy. It\'s the opposite of SQS: SQS is one-to-one, SNS is one-to-many.',
    useCases: [
      'Sending notifications (email, SMS, push)',
      'Fan-out: one event triggers multiple processors',
      'Alerting on CloudWatch alarms',
    ],
    keyTerms: {
      Topic: 'A channel that messages are published to',
      Subscription: 'A listener that receives messages from a topic',
      'Fan-out': 'Pattern where one message goes to many subscribers',
    },
    pricing: 'Free tier: 1M publishes, 1K emails, 100 SMS/month. After: $0.50/million publishes.',
  },
  {
    id: 'kinesis',
    name: 'Kinesis',
    fullName: 'Amazon Kinesis',
    cat: 'serverless',
    level: 'advanced',
    icon: '\u{1F30A}',
    short: 'Real-time data streaming. Process and analyze massive streams of data (logs, events, IoT) as they arrive.',
    analogy: 'A fast-flowing river of data \u2014 you can dip a bucket in at any point to sample and process what\'s flowing by.',
    detail: 'Kinesis handles real-time streaming data at scale. Kinesis Data Streams ingests data, Kinesis Data Firehose delivers it to storage (S3, Redshift), and Kinesis Data Analytics lets you query streams with SQL. It\'s designed for scenarios where you need to process thousands to millions of records per second with low latency.',
    useCases: [
      'Real-time log aggregation',
      'Clickstream analytics',
      'IoT data processing',
      'Live dashboards',
    ],
    keyTerms: {
      Shard: 'A unit of capacity in a stream (1 MB/s in, 2 MB/s out)',
      'Data Stream': 'The main ingestion pipeline',
      Firehose: 'Automatically delivers stream data to storage destinations',
    },
    pricing: 'Data Streams: $0.015/shard/hr. Firehose: $0.029/GB ingested.',
  },
]
