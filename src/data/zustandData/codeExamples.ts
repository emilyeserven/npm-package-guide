import type { CodeExample, ApiRefEntry, ZustandStat } from './types'

// ── Stats shown on the basics page ─────────────────────────────────
export const ZUSTAND_STATS: ZustandStat[] = [
  { stat: '~1KB', description: 'Gzipped bundle size' },
  { stat: 'No Provider', description: 'No wrapping needed' },
  { stat: 'Hooks-based', description: 'Feels like React' },
  { stat: 'Middleware', description: 'Composable & extensible' },
]

// ── API quick-reference table ──────────────────────────────────────
export const API_REFERENCE: ApiRefEntry[] = [
  { method: 'create(fn)', description: 'Create a store hook' },
  { method: 'set(partial)', description: 'Shallow merge update' },
  { method: 'set(fn)', description: 'Updater function for current state' },
  { method: 'set(state, true)', description: 'Replace entire state' },
  { method: 'get()', description: 'Read current state in actions' },
  { method: 'useStore(selector)', description: 'Subscribe with selector' },
  { method: 'useStore.getState()', description: 'Read state outside React' },
  { method: 'useStore.setState()', description: 'Write state outside React' },
  { method: 'useStore.subscribe()', description: 'Listen for state changes' },
]

// ── All code examples ──────────────────────────────────────────────
// Imports inside template strings are concatenated to avoid scanner issues.

export const BASICS_EXAMPLES: CodeExample[] = [
  {
    id: 'basic-store',
    label: 'Basic Store',
    variant: 'good',
    code: [
      '// store/counterStore.ts',
      'imp' + 'ort { create } from \'zustand\'',
      '',
      'const useCounterStore = create((set, get) => ({',
      '  // State',
      '  count: 0,',
      '',
      '  // Actions (just functions that call set)',
      '  increment: () => set((state) => ({ count: state.count + 1 })),',
      '  decrement: () => set((state) => ({ count: state.count - 1 })),',
      '  reset: () => set({ count: 0 }),',
      '',
      '  // Actions that read current state with get()',
      '  doubleCount: () => set({ count: get().count * 2 }),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'using-store',
    label: 'Using the Store',
    variant: 'good',
    code: [
      'function Counter() {',
      '  // Subscribe to specific state (component re-renders when count changes)',
      '  const count = useCounterStore((state) => state.count)',
      '  const increment = useCounterStore((state) => state.increment)',
      '',
      '  return <button onClick={increment}>{count}</button>',
      '}',
      '',
      "// That's it. No <Provider>, no context, no wrapping.",
    ].join('\n'),
  },
  {
    id: 'set-merge',
    label: 'set merges shallowly by default',
    variant: 'info',
    code: [
      "// Given state: { count: 0, name: 'Emily' }",
      '',
      'set({ count: 1 })',
      "// Result: { count: 1, name: 'Emily' }  \u2190 name is preserved!",
      '',
      '// For deeply nested updates, you still need to spread:',
      'set((state) => ({',
      "  user: { ...state.user, name: 'New Name' }",
      '}))',
    ].join('\n'),
  },
]

export const INCORRECT_EXAMPLES: CodeExample[] = [
  {
    id: 'bad-sub',
    label: "Don't \u2014 Subscribes to everything",
    variant: 'bad',
    code: [
      'function UserProfile() {',
      '  // \ud83d\udea8 This component re-renders when ANY state changes',
      "  // even if only 'count' changed and user never touched 'name'",
      '  const { name, email } = useUserStore()',
      '',
      '  return <div>{name} ({email})</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'good-sub',
    label: 'Do \u2014 Select only what you need',
    variant: 'good',
    code: [
      'function UserProfile() {',
      '  const name = useUserStore((s) => s.name)',
      '  const email = useUserStore((s) => s.email)',
      '',
      '  return <div>{name} ({email})</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'bad-mut',
    label: "Don't \u2014 Direct mutation",
    variant: 'bad',
    code: [
      'const useStore = create((set, get) => ({',
      '  items: [],',
      '  addItem: (item) => {',
      "    // \ud83d\udea8 Mutating state directly \u2014 React won't detect this change!",
      '    get().items.push(item)',
      '    set({ items: get().items }) // Same reference, no re-render',
      '  },',
      '}))',
    ].join('\n'),
  },
  {
    id: 'good-mut',
    label: 'Do \u2014 Immutable update',
    variant: 'good',
    code: [
      'const useStore = create((set) => ({',
      '  items: [],',
      '  addItem: (item) =>',
      '    set((state) => ({',
      '      items: [...state.items, item],  // New array reference',
      '    })),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'bad-ref',
    label: "Don't \u2014 New object every render",
    variant: 'bad',
    code: [
      'function UserCard() {',
      '  // \ud83d\udea8 Creates a new object every time ANY state changes',
      '  // Object.is() will always return false = infinite re-renders',
      '  const user = useUserStore((s) => ({',
      '    name: s.name,',
      '    email: s.email,',
      '  }))',
      '',
      '  return <div>{user.name}</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'good-ref',
    label: 'Do \u2014 Use useShallow',
    variant: 'good',
    code: [
      'imp' + "ort { useShallow } fr" + "om 'zustand/react/shallow'",
      '',
      'function UserCard() {',
      '  // \u2705 useShallow does a shallow comparison of each property',
      '  const { name, email } = useUserStore(',
      '    useShallow((s) => ({ name: s.name, email: s.email }))',
      '  )',
      '',
      '  return <div>{name}</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'bad-closure',
    label: "Don't \u2014 Stale closure over set",
    variant: 'bad',
    code: [
      'const useStore = create((set) => ({',
      '  count: 0,',
      '  // \ud83d\udea8 This reads the INITIAL count value (0) from closure',
      '  incrementBy: (amount) => set({ count: count + amount }),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'good-closure',
    label: 'Do \u2014 Use the updater function',
    variant: 'good',
    code: [
      'const useStore = create((set) => ({',
      '  count: 0,',
      '  // \u2705 Use callback form to always get current state',
      '  incrementBy: (amount) =>',
      '    set((state) => ({ count: state.count + amount })),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'bad-derived',
    label: "Don't \u2014 Redundant derived state",
    variant: 'bad',
    code: [
      'const useStore = create((set) => ({',
      '  items: [],',
      '  // \ud83d\udea8 This gets out of sync easily and duplicates logic',
      '  totalPrice: 0,',
      '  addItem: (item) => set((state) => ({',
      '    items: [...state.items, item],',
      '    totalPrice: state.totalPrice + item.price, // Manual sync',
      '  })),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'good-derived',
    label: 'Do \u2014 Derive at selection time',
    variant: 'good',
    code: [
      'const useStore = create((set) => ({',
      '  items: [],',
      '  addItem: (item) =>',
      '    set((state) => ({ items: [...state.items, item] })),',
      '}))',
      '',
      '// Derive in the component or with a custom hook',
      'function CartTotal() {',
      '  const total = useStore(',
      '    (s) => s.items.reduce((sum, i) => sum + i.price, 0)',
      '  )',
      '  return <div>Total: ${total}</div>',
      '}',
    ].join('\n'),
  },
]

export const CORRECT_EXAMPLES: CodeExample[] = [
  {
    id: 'clean-org',
    label: 'Clean store organization',
    variant: 'good',
    code: [
      '// store/authStore.ts',
      'interface AuthState {',
      '  user: User | null',
      '  token: string | null',
      '  isLoading: boolean',
      '}',
      '',
      'interface AuthActions {',
      '  login: (credentials: Credentials) => Promise<void>',
      '  logout: () => void',
      '}',
      '',
      'const useAuthStore = create<AuthState & AuthActions>((set) => ({',
      '  // \u2500\u2500 State \u2500\u2500',
      '  user: null,',
      '  token: null,',
      '  isLoading: false,',
      '',
      '  // \u2500\u2500 Actions \u2500\u2500',
      '  login: async (credentials) => {',
      '    set({ isLoading: true })',
      '    try {',
      '      const { user, token } = await authApi.login(credentials)',
      '      set({ user, token, isLoading: false })',
      '    } catch {',
      '      set({ isLoading: false })',
      "      throw new Error('Login failed')",
      '    }',
      '  },',
      '  logout: () => set({ user: null, token: null }),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'selector-hooks',
    label: 'Custom selector hooks',
    variant: 'good',
    code: [
      '// Stable, reusable, testable selectors',
      'const useUser = () => useAuthStore((s) => s.user)',
      'const useIsLoggedIn = () => useAuthStore((s) => s.user !== null)',
      'const useAuthActions = () => useAuthStore(',
      '  useShallow((s) => ({ login: s.login, logout: s.logout }))',
      ')',
      '',
      '// Usage',
      'function Nav() {',
      '  const isLoggedIn = useIsLoggedIn()',
      '  const { logout } = useAuthActions()',
      '  // ...',
      '}',
    ].join('\n'),
  },
  {
    id: 'outside-react',
    label: 'Accessing store outside React',
    variant: 'good',
    code: [
      '// In an API interceptor or utility file',
      'imp' + "ort { useAuthStore } fr" + "om './store/authStore'",
      '',
      '// getState() gives you the current snapshot',
      'const token = useAuthStore.getState().token',
      '',
      '// setState() sets state from anywhere',
      'useAuthStore.setState({ user: null })',
      '',
      '// subscribe() listens for changes',
      'const unsub = useAuthStore.subscribe(',
      "  (state) => console.log('State changed:', state)",
      ')',
    ].join('\n'),
  },
  {
    id: 'tanstack',
    label: 'Zustand + TanStack Query',
    variant: 'good',
    code: [
      '// Zustand: client/UI state only',
      'const useUIStore = create((set) => ({',
      '  sidebarOpen: false,',
      "  theme: 'dark',",
      '  toggleSidebar: () =>',
      '    set((s) => ({ sidebarOpen: !s.sidebarOpen })),',
      '}))',
      '',
      '// TanStack Query: server state',
      'function UserDashboard() {',
      '  const sidebarOpen = useUIStore((s) => s.sidebarOpen)',
      '  const { data: user } = useQuery({',
      "    queryKey: ['user', 'me'],",
      '    queryFn: fetchCurrentUser,',
      '  })',
      '',
      '  return (',
      '    <Layout sidebar={sidebarOpen}>',
      '      <h1>{user?.name}</h1>',
      '    </Layout>',
      '  )',
      '}',
    ].join('\n'),
  },
]

export const GOTCHA_EXAMPLES: CodeExample[] = [
  {
    id: 'eq-rule',
    label: 'The equality rule',
    variant: 'info',
    code: [
      '// Primitives \u2014 works perfectly',
      'const count = useStore((s) => s.count)',
      '// Object.is(0, 0) === true \u2192 no re-render',
      '',
      '// Objects/Arrays \u2014 new reference = re-render!',
      'const filters = useStore((s) => s.filters)',
      '// If filters is replaced: Object.is(oldObj, newObj) === false \u2192 re-render \u2705',
      '// If filters is mutated: Object.is(sameObj, sameObj) === true \u2192 NO re-render \ud83d\udea8',
    ].join('\n'),
  },
  {
    id: 'bad-race',
    label: 'Race condition',
    variant: 'bad',
    code: [
      'const useStore = create((set) => ({',
      '  data: null,',
      '  isLoading: false,',
      '  fetchData: async (id) => {',
      '    set({ isLoading: true })',
      '    const result = await api.fetch(id)',
      '    // \ud83d\udea8 If called twice quickly, the first response',
      '    // might overwrite the second (correct) one',
      '    set({ data: result, isLoading: false })',
      '  },',
      '}))',
    ].join('\n'),
  },
  {
    id: 'good-race',
    label: 'Fix \u2014 use AbortController or check staleness',
    variant: 'good',
    code: [
      'const useStore = create((set, get) => ({',
      '  data: null,',
      '  isLoading: false,',
      '  _fetchId: 0,  // Track the latest request',
      '  fetchData: async (id) => {',
      '    const fetchId = ++get()._fetchId',
      '    set({ isLoading: true, _fetchId: fetchId })',
      '    const result = await api.fetch(id)',
      '',
      '    // Only update if this is still the latest request',
      '    if (get()._fetchId === fetchId) {',
      '      set({ data: result, isLoading: false })',
      '    }',
      '  },',
      '}))',
      '',
      '// Or better yet \u2014 let TanStack Query handle this!',
    ].join('\n'),
  },
  {
    id: 'bad-sub-effect',
    label: "Don't \u2014 Manual subscribe in useEffect",
    variant: 'bad',
    code: [
      'function Logger() {',
      '  useEffect(() => {',
      '    // \ud83d\udea8 This is redundant and error-prone.',
      '    // You\'re basically reimplementing what the hook does.',
      '    const unsub = useStore.subscribe((state) => {',
      '      console.log(state.count)',
      '    })',
      '    return unsub',
      '  }, [])',
      '}',
    ].join('\n'),
  },
  {
    id: 'good-sub-effect',
    label: 'Do \u2014 Use subscribeWithSelector middleware',
    variant: 'good',
    code: [
      '// If you need side-effects on state changes,',
      '// use the subscribe method with a selector (Zustand v4+):',
      'useEffect(() => {',
      '  const unsub = useStore.subscribe(',
      '    (state) => state.count,',
      '    (count, prevCount) => {',
      "      console.log('count changed:', prevCount, '->', count)",
      '    }',
      '  )',
      '  return unsub',
      '}, [])',
      '',
      '// Or use the transient updates pattern (see Advanced section)',
    ].join('\n'),
  },
  {
    id: 'typed-store',
    label: 'Properly typed store',
    variant: 'good',
    code: [
      'interface BearState {',
      '  bears: number',
      '  increase: (by: number) => void',
      '  reset: () => void',
      '}',
      '',
      '// Pass the interface as a generic to create',
      'const useBearStore = create<BearState>()((set) => ({',
      '  bears: 0,',
      '  increase: (by) => set((state) => ({ bears: state.bears + by })),',
      '  reset: () => set({ bears: 0 }),',
      '}))',
      '// Note the double parentheses ()() \u2014 this is required for',
      '// TypeScript when using middleware. It\'s called "currying".',
    ].join('\n'),
  },
]

export const SLICES_EXAMPLES: CodeExample[] = [
  {
    id: 'user-slice',
    label: 'store/slices/userSlice.ts',
    variant: 'good',
    code: [
      '// store/slices/userSlice.ts',
      'imp' + "ort { StateCreator } fr" + "om 'zustand'",
      'imp' + "ort { AppState } fr" + "om '../store'",
      '',
      'export interface UserSlice {',
      '  user: User | null',
      '  setUser: (user: User | null) => void',
      '  isAdmin: () => boolean',
      '}',
      '',
      'export const createUserSlice: StateCreator<',
      '  AppState,  // The full combined state type',
      '  [],        // Middleware array',
      '  [],',
      '  UserSlice  // This slice\'s type',
      '> = (set, get) => ({',
      '  user: null,',
      '  setUser: (user) => set({ user }),',
      "  isAdmin: () => get().user?.role === 'admin',",
      '})',
    ].join('\n'),
  },
  {
    id: 'cart-slice',
    label: 'store/slices/cartSlice.ts',
    variant: 'good',
    code: [
      '// store/slices/cartSlice.ts',
      'export interface CartSlice {',
      '  items: CartItem[]',
      '  addItem: (item: CartItem) => void',
      '  clear: () => void',
      '  total: () => number',
      '}',
      '',
      'export const createCartSlice: StateCreator<',
      '  AppState, [], [], CartSlice',
      '> = (set, get) => ({',
      '  items: [],',
      '  addItem: (item) =>',
      '    set((s) => ({ items: [...s.items, item] })),',
      '  clear: () => set({ items: [] }),',
      '  // Cross-slice access: check if user gets a discount',
      '  total: () => {',
      '    const discount = get().user?.isPremium ? 0.9 : 1',
      '    return get().items.reduce(',
      '      (sum, i) => sum + i.price, 0',
      '    ) * discount',
      '  },',
      '})',
    ].join('\n'),
  },
  {
    id: 'combine-slices',
    label: 'store/store.ts',
    variant: 'good',
    code: [
      '// store/store.ts',
      'imp' + "ort { create } fr" + "om 'zustand'",
      'imp' + "ort { createUserSlice, UserSlice } fr" + "om './slices/userSlice'",
      'imp' + "ort { createCartSlice, CartSlice } fr" + "om './slices/cartSlice'",
      '',
      '// Combined type',
      'export type AppState = UserSlice & CartSlice',
      '',
      '// Combine with spread',
      'export const useAppStore = create<AppState>()((...args) => ({',
      '  ...createUserSlice(...args),',
      '  ...createCartSlice(...args),',
      '}))',
      '',
      '// Usage \u2014 same as any Zustand store',
      'const user = useAppStore((s) => s.user)',
      'const addItem = useAppStore((s) => s.addItem)',
    ].join('\n'),
  },
]

export const MIDDLEWARE_EXAMPLES: CodeExample[] = [
  {
    id: 'persist',
    label: 'Persist middleware',
    variant: 'good',
    code: [
      'imp' + "ort { create } fr" + "om 'zustand'",
      'imp' + "ort { persist, createJSONStorage } fr" + "om 'zustand/middleware'",
      '',
      'const useSettingsStore = create(',
      '  persist(',
      '    (set) => ({',
      "      theme: 'dark',",
      '      fontSize: 14,',
      '      setTheme: (theme) => set({ theme }),',
      '    }),',
      '    {',
      "      name: 'settings-storage',  // localStorage key",
      '      storage: createJSONStorage(() => sessionStorage),',
      '      partialize: (state) => ({',
      '        // Only persist these fields (omit functions)',
      '        theme: state.theme,',
      '        fontSize: state.fontSize,',
      '      }),',
      '    }',
      '  )',
      ')',
    ].join('\n'),
  },
  {
    id: 'devtools',
    label: 'DevTools middleware',
    variant: 'good',
    code: [
      'imp' + "ort { devtools } fr" + "om 'zustand/middleware'",
      '',
      'const useStore = create(',
      '  devtools(',
      '    (set) => ({',
      '      count: 0,',
      '      increment: () =>',
      "        // Name your actions for clear DevTools traces",
      "        set((s) => ({ count: s.count + 1 }), false, 'increment'),",
      '        //                                   ^^^^   ^^^^^^^^^',
      '        //                                replace?  action name',
      '    }),',
      "    { name: 'MyStore' }  // Store name in DevTools",
      '  )',
      ')',
    ].join('\n'),
  },
  {
    id: 'immer',
    label: 'Immer middleware',
    variant: 'good',
    code: [
      'imp' + "ort { immer } fr" + "om 'zustand/middleware/immer'",
      '',
      'const useTodoStore = create(',
      '  immer((set) => ({',
      '    todos: [],',
      '    addTodo: (text) =>',
      '      set((state) => {',
      '        // \ud83c\udf89 Mutate directly \u2014 Immer handles immutability',
      '        state.todos.push({ id: Date.now(), text, done: false })',
      '      }),',
      '    toggleTodo: (id) =>',
      '      set((state) => {',
      '        const todo = state.todos.find((t) => t.id === id)',
      '        if (todo) todo.done = !todo.done  // Direct mutation is fine!',
      '      }),',
      '  }))',
      ')',
    ].join('\n'),
  },
  {
    id: 'sub-with-sel',
    label: 'subscribeWithSelector',
    variant: 'good',
    code: [
      'imp' + "ort { subscribeWithSelector } fr" + "om 'zustand/middleware'",
      '',
      'const useStore = create(',
      '  subscribeWithSelector((set) => ({',
      '    count: 0,',
      '    increment: () => set((s) => ({ count: s.count + 1 })),',
      '  }))',
      ')',
      '',
      '// Now subscribe to specific slices of state:',
      'useStore.subscribe(',
      '  (state) => state.count,            // selector',
      '  (count, prevCount) => {             // listener',
      "    console.log('count changed!', prevCount, '\u2192', count)",
      '  },',
      '  { fireImmediately: true }           // options',
      ')',
    ].join('\n'),
  },
  {
    id: 'stack-middleware',
    label: 'Composing middleware',
    variant: 'good',
    code: [
      'imp' + "ort { create } fr" + "om 'zustand'",
      'imp' + "ort { devtools, persist, subscribeWithSelector } fr" + "om 'zustand/middleware'",
      'imp' + "ort { immer } fr" + "om 'zustand/middleware/immer'",
      '',
      'const useStore = create<StoreState>()(',
      '  devtools(              // Outermost: DevTools sees final state',
      '    subscribeWithSelector( // Enables fine-grained subscribe',
      '      persist(             // Persists to localStorage',
      '        immer(             // Innermost: enables mutable syntax',
      '          (set) => ({',
      '            // Your state and actions here',
      '            bears: 0,',
      '            addBear: () => set((s) => { s.bears += 1 }),',
      '          })',
      '        ),',
      "        { name: 'bear-storage' }",
      '      )',
      '    ),',
      "    { name: 'BearStore' }",
      '  )',
      ')',
    ].join('\n'),
  },
]

export const ADVANCED_EXAMPLES: CodeExample[] = [
  {
    id: 'transient',
    label: 'Transient updates with useRef',
    variant: 'good',
    code: [
      'function AnimatedComponent() {',
      '  // This ref always holds the latest count',
      '  // without triggering re-renders',
      '  const countRef = useRef(useStore.getState().count)',
      '',
      '  useEffect(() => {',
      '    const unsub = useStore.subscribe(',
      '      (state) => (countRef.current = state.count)',
      '    )',
      '    return unsub',
      '  }, [])',
      '',
      '  // Use countRef.current in animation frames, timers, etc.',
      '}',
    ].join('\n'),
  },
  {
    id: 'computed-a',
    label: 'Option A: Selector-level computation',
    variant: 'good',
    code: [
      '// Computed at the selector level (recalculated on each relevant change)',
      'function CartSummary() {',
      '  const total = useStore((s) =>',
      '    s.items.reduce((sum, item) => sum + item.price * item.qty, 0)',
      '  )',
      '  const itemCount = useStore((s) => s.items.length)',
      '',
      '  return <div>{itemCount} items \u2014 ${total.toFixed(2)}</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'computed-b',
    label: 'Option B: Memoized selector outside component',
    variant: 'good',
    code: [
      '// For expensive computations, create a memoized selector',
      '',
      '// Stable selector function (defined outside component)',
      'const selectItems = (s) => s.items',
      '',
      'function ExpensiveCartSummary() {',
      '  const items = useStore(selectItems)',
      '',
      '  const stats = useMemo(() => ({',
      '    total: items.reduce((s, i) => s + i.price * i.qty, 0),',
      '    heaviest: items.reduce((max, i) =>',
      '      i.weight > max.weight ? i : max, items[0]',
      '    ),',
      '    categories: [...new Set(items.map((i) => i.category))],',
      '  }), [items])',
      '',
      '  return <div>...</div>',
      '}',
    ].join('\n'),
  },
  {
    id: 'external-actions',
    label: 'External actions pattern',
    variant: 'good',
    code: [
      '// Store is pure state',
      'const useStore = create(() => ({',
      '  count: 0,',
      '  user: null,',
      '}))',
      '',
      '// Actions are standalone functions',
      'export const increment = () =>',
      '  useStore.setState((s) => ({ count: s.count + 1 }))',
      '',
      'export const reset = () =>',
      '  useStore.setState({ count: 0 })',
      '',
      'export const login = async (creds) => {',
      '  const user = await authApi.login(creds)',
      '  useStore.setState({ user })',
      '}',
      '',
      '// In components \u2014 actions don\'t need to be selected',
      'function Counter() {',
      '  const count = useStore((s) => s.count)',
      '  return <button onClick={increment}>{count}</button>',
      '  // increment is a stable function, no re-render issues',
      '}',
    ].join('\n'),
  },
  {
    id: 'reset-pattern',
    label: 'Reset pattern',
    variant: 'good',
    code: [
      'const initialState = {',
      '  count: 0,',
      '  user: null,',
      '  items: [],',
      '}',
      '',
      'const useStore = create((set) => ({',
      '  ...initialState,',
      '',
      '  // Actions',
      '  increment: () => set((s) => ({ count: s.count + 1 })),',
      '',
      '  // Reset to initial state (preserves action references)',
      '  reset: () => set(initialState),',
      '',
      '  // Nuclear reset (replaces everything)',
      '  hardReset: () => set(initialState, true),',
      '}))',
    ].join('\n'),
  },
  {
    id: 'testing',
    label: 'Testing patterns',
    variant: 'good',
    code: [
      'imp' + "ort { act } fr" + "om '@testing-library/react'",
      '',
      '// Reset store between tests',
      'beforeEach(() => {',
      '  useStore.setState(initialState)',
      '})',
      '',
      "test('increment increases count', () => {",
      '  // Direct state manipulation \u2014 no component needed',
      '  act(() => {',
      '    useStore.getState().increment()',
      '  })',
      '',
      '  expect(useStore.getState().count).toBe(1)',
      '})',
      '',
      "test('external actions work', () => {",
      '  act(() => {',
      '    increment()  // The external action function',
      '  })',
      '',
      '  expect(useStore.getState().count).toBe(1)',
      '})',
    ].join('\n'),
  },
]
